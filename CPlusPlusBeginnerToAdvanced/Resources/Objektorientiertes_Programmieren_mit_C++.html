<!DOCTYPE html>
<html lang="de">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="Martin Kompf" name="author">
<meta content="C++, Cplusplus, Cplus, Objektorientiert, Programmieren, Programmierung, Tutorial" name="keywords">
<meta content="Tutorial zum Objektorientierten Programmieren mit C++" name="description">
<meta content="Martin Kompf" name="publisher">
<meta content="NEVER" name="expires">
<meta content="INDEX,FOLLOW" name="robots">
<title>Objektorientiertes Programmieren mit C++</title>

<style media="all" type="text/css">
@import "/style/kompf.css";
</style>

<style media="print" type="text/css">
@import "/style/kompf-print.css";
</style>

<style media="only screen and (max-width: 480px)" type="text/css">
@import "/style/kompf-mobile.css";
</style>
<meta content="2020-07-11T18:44:59+02:00" name="date">
<meta content="initial-scale=1, minimum-scale=0.75, width=device-width" name="viewport">
<link href="https://www.kompf.de/cplus/tutor.html" rel="canonical">
</head>
<body>
<img alt="" height="1" src="https://ssl-vg03.met.vgwort.de/na/3db6494a08993014b12a67fa037550" width="1">
<div id="Header"><a href="//www.kompf.de">Kompf.de</a> &gt; <a href="//www.kompf.de/cplus">C/C++</a></div>
<div id="Content">
<h1>Objektorientiertes Programmieren mit C++</h1>
<p class="author">Martin Kompf</p>
<h2 id="inhalt">Inhalt</h2>
<ul class="toc">
<li><a href="#inhalt">Inhalt</a></li>
<li><a href="#objekte">Objekte</a></li>
<li><a href="#klassen">Klassen</a>
<ul>
<li><a href="#klassen_als_bauplan">Klassen als Bauplan</a></li>
<li><a href="#klassendefinition">Klassendefinition</a></li>
</ul>
</li>
<li><a href="#objektlebenszyklus">Objektlebenszyklus</a>
<ul>
<li><a href="#erzeugen_eines_objektes">Erzeugen eines Objektes</a></li>
<li><a href="#benutzen_eines_objektes">Benutzen eines Objektes</a></li>
<li><a href="#zerst">Zerst</a></li>
</ul>
</li>
<li><a href="#objektimplementierung">Objektimplementierung</a></li>
<li><a href="#vererbung">Vererbung</a>
<ul>
<li><a href="#konzept">Konzept</a></li>
<li><a href="#vererbung_in_c__">Vererbung in C++</a></li>
<li><a href="#implementierung_der_abgeleiteten_klasse">Implementierung der abgeleiteten Klasse</a></li>
<li><a href="#verwendung_abgeleiteter_klassen">Verwendung abgeleiteter Klassen</a></li>
<li><a href="#download">Download</a></li>
</ul>
</li>
</ul>
<div></div>
<h2 id="objekte">Objekte</h2>
<p>C++ ist nicht nur das bessere C, sondern bietet dem Entwickler die Möglichkeit, objektorientiert zu programmieren. Dies verlangt neben dem Erlernen neuer Sprachelemente auch eine neue "objektorientierte" Denkweise. In Form eines Tutorials soll hier mit dieser Denkweise vertraut gemacht werden.</p>
<p>Herkömmliche Softwareentwicklung bestand oftmals darin, zur Lösung eines vorgegebenen Problems Algorithmen zu entwerfen und diese in Prozeduren zu gießen, die in einer Programmiersprache - wie zum Beispiel C - formuliert sind. Man spricht daher auch von prozeduraler Programmierung.</p>
<p>Betrachtet man jedoch die reale Welt, so stellt man fest, daß die Dinge sich hier nicht in einer abstrakten prozeduralen Weise bewegen. Diesen Bruch zwischen realer Welt und Softwareentwicklung versucht der objektorientierte Ansatz zu überwinden. Analysiert man seine materielle Umgebung, so stellt man fest, daß diese im wesentlichen aus Objekten besteht, die in verschiedener Art und Weise miteinander agieren. So könnte es in unserer unmittelbaren Umgebung gerade ein Objekt Fahrrad geben.</p>
<p><img align="left" alt="Objekt" height="160" src="images/art2s.gif" width="165"> Nimmt man das Fahrrad noch weiter unter die Lupe, erkennt man, daß dieses Fahrrad bestimmte <em>Eigenschaften</em> bzw. <em>Attribute</em> (wie Farbe, Größe, momentane Geschwindigkeit) besitzt und daß es <em>Methoden</em> gibt, diese Eigenschaften zu verändern (z.B. die Methode "Tritt schneller", die zu einer Erhöhung der Geschwindigkeit führen wird oder die Methode "Bremse", die das Gegenteil bewirken sollte).</p>
<p>Transformiert man diese Erkenntnis aus der realen in die Software-Welt, so kann man formulieren:</p>
<p class="definition">Ein Software-Objekt ist ein Bündel aus Attributen und darauf bezogenen Methoden.</p>
<h2 id="klassen">Klassen</h2>
<h3 id="klassen_als_bauplan">Klassen als Bauplan</h3>
<p>Wenn wir verschiedene Fahrrad-Objekte der realen Welt genauer betrachten, so stellen wir fest, daß alle diese Fahrrad-Objekte ähnlich sind: Alle besitzen Bremsen, alle haben irgendeine Farbe usw. Es muß also einen <em>Bauplan</em> geben, der beschreibt, wie ein Fahrrad grundsätzlich auszusehen hat. Alle Fahrrad-Objekte sind nach diesem Bauplan erstellt worden - deswegen ist es uns auch möglich, ein beliebiges Fahrrad zu fahren, wenn wir einmal das Fahrradfahren gelernt haben! Wieder übertragen wir diese Erkenntnis in die Softwarewelt:</p>
<p class="definition">Eine Klasse ist ein Bauplan, welcher die Attribute und Methoden definiert, die alle Objekte einer bestimmten Art besitzen.</p>
<p><img align="left" alt="class StockItem" height="127" src="images/art4.gif" width="173"> Die Abbildung zeigt eine Klasse <tt>StockItem</tt> in der sogenannten UML (unified modelling language) Notation. Diese Klasse könnte in einem Programm zur Aktienanalyse verwendet werden. Ein solches Programm muß viele verschiedene Aktien-Objekte verwalten können. Damit dies effektiv geschehen kann, sollten alle diese verschiedenen Objekte jedoch nach einem einheitlichen Bauplan - der Klassendefinition - erstellt werden.</p>
<p>Der Name der Klasse steht in der UML-Notation im oberen Drittel des Rechtecks. Im mittleren Drittel stehen die Attribute. Unsere Beispielklasse <tt>StockItem</tt> definiert die zwei Attribute m_name und m_value, d.h. den Namen der Aktie und den momentanen Kurswert. Das Minuszeichen vor den Attributen bedeutet, das diese <tt class="keyword">private</tt> Mitglieder der Klasse sind, d.h. von außen kann nicht direkt auf sie zugegriffen werden.</p>
<p>Im unteren Drittel stehen die Methoden der Klasse <tt>StockItem</tt>. Das Pluszeichen vor ihnen zeigt, daß sie <tt class="keyword">public</tt> sind, d.h. die Methoden dürfen von anderen Objekten aufgerufen werden. Damit zeigt sich das Prinzip der Kapselung: Anstatt auf das Attribut m_value direkt zuzugreifen, <em>müssen</em> andere Objekte die Zugriffsmethoden setValue() und getValue() benutzen! So hat der Entwickler der Klasse die Möglichkeit, in setValue() noch zusätzliche Abfragen, z.B. bezüglich der Gültigkeit des Parameters, einzubauen.</p>
<p>Aufmerksamen Lesern wird bei Betrachtung der Abbildung eine Erweiterung von C++ gegenüber C nicht entgangen sein: Funktionen werden in C++ nicht nur - wie in C - durch den Namen, sondern durch Namen <em>und</em> Parameteranzahl und -typ unterschieden! So kann es die Methode setValue() zweimal geben: Einmal mit einem Parameter vom Typ <tt class="keyword">double</tt> und mit einem vom Typ <tt><span class="keyword">const char</span>*</tt>. Der Compiler erkennt beim Aufruf dieser Methode anhand des Parametertyps selbsttätig, welche Variante er verwenden muß.</p>
<h3 id="klassendefinition">Klassendefinition</h3>
<p>Es ist angebracht, C++-Klassendefinitionen generell in Headerdateien (das sind die mit der Extension .h) vorzunehmen. Guter Programmierstil ist dabei, jeweils eine Headerdatei je Klasse vorzusehen und diese auch wie die Klasse zu benennen.</p>
<p>Die Klassendefinition für StockItem wird also in der Headerdatei mit dem Namen <b>StockItem.h</b> vorgenommen:</p>
<pre class="cplus">
<span class="comment">/*  1 */</span>  <span class="preprocessor">#ifndef StockItem_h</span>
<span class="comment">/*  2 */</span>  <span class="preprocessor">#define StockItem_h 1</span>
<span class="comment">/*  3 */</span>
<span class="comment">/*  4 */</span>  <span class="keyword">class</span> StockItem {
<span class="comment">/*  5 */</span>
<span class="comment">/*  6 */</span>  <span class="keyword">public</span>:
<span class="comment">/*  7 */</span>      <span class="slashslashcomment">// ctor</span>
<span class="comment">/*  8 */</span>      StockItem( <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="quotedstring">""</span>, <span class="keyword">double</span> val = 0.0);
<span class="comment">/*  9 */</span>
<span class="comment">/* 10 */</span>      <span class="slashslashcomment">// copy ctor</span>
<span class="comment">/* 11 */</span>      StockItem( <span class="keyword">const</span> StockItem &amp;right);
<span class="comment">/* 12 */</span>      <span class="slashslashcomment">// dtor</span>
<span class="comment">/* 13 */</span>      <span class="keyword">virtual</span> ~StockItem();
<span class="comment">/* 14 */</span>      <span class="slashslashcomment">// assignment operator</span>
<span class="comment">/* 15 */</span>      <span class="keyword">const</span> StockItem&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StockItem &amp;right);
<span class="comment">/* 16 */</span>
<span class="comment">/* 17 */</span>      <span class="slashslashcomment">// public member functions</span>
<span class="comment">/* 18 */</span>      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* getName() <span class="keyword">const</span>;
<span class="comment">/* 19 */</span>      <span class="keyword">virtual</span> <span class="keyword">void</span> setValue( <span class="keyword">double</span> val);
<span class="comment">/* 20 */</span>      <span class="keyword">virtual</span> <span class="keyword">void</span> setValue( <span class="keyword">const</span> <span class="keyword">char</span>* val);
<span class="comment">/* 21 */</span>      <span class="keyword">virtual</span> <span class="keyword">double</span> getValue() <span class="keyword">const</span>;
<span class="comment">/* 22 */</span>
<span class="comment">/* 23 */</span>  <span class="keyword">private</span>:
<span class="comment">/* 24 */</span>      <span class="slashslashcomment">// private member variables</span>
<span class="comment">/* 25 */</span>      <span class="keyword">char</span> *m_name;
<span class="comment">/* 26 */</span>      <span class="keyword">double</span> m_value;
<span class="comment">/* 27 */</span>  };
<span class="comment">/* 28 */</span>
<span class="comment">/* 29 */</span>  <span class="preprocessor">#endif </span>
</pre>
<p>Die Klassendefinition beginnt mit dem Schlüsselwort <tt class="keyword">class</tt> gefolgt vom Namen der Klasse (Zeile 4). Die eigentliche Definition wird von geschweiften Klammern { } umschlossen. Die Schlüsselwörter <tt class="keyword">public</tt> und <tt class="keyword">private</tt> trennen die im letzten Abschnitt besprochenen öffentlichen (Zeilen 7 bis 21) und privaten (Zeilen 24 bis 26) Bereiche der Definition ab. Es gibt außerdem noch die Möglichkeit, mittels <tt class="keyword">protected</tt> Variablen und Methoden zu deklarieren, die ausschließlich abgeleiteten Klassen zur Verfügung stehen sollen. Dazu mehr später mehr beim Thema <em>Vererbung</em>.</p>
<p>Die Deklaration der öffentlichen Methoden (Zeilen 18 bis 19) und der privaten Variablen (Zeilen 25 und 26) erfolgt genauso wie eine normale Deklaration von Funktionen bzw. Variablen in C. Bei den Funktionen fällt die Verwendung der Spezifikation <tt class="keyword">virtual</tt> auf. Dies ist wiederum für das Thema <em>Vererbung</em> wichtig und wird später besprochen. Man macht jedoch nicht viel verkehrt, wenn man direkt jeder Funktion von vorneherein diese Spezifikation verpaßt.</p>
<p>Auf den Zeilen 7 bis 15 werden <em>Constructor</em>, <em>Copy-Constructor</em>, <em>Destructor</em> und <em>Assignment Operator</em> deklariert. Um den Sinn dieser Elemente verstehen zu können, müssen wir zunächst auf den <em>Objektlebenszyklus</em> eingehen</p>
<p><em>PS: Noch ein kleiner Tip: Der Compiler produziert die wunderlichsten Fehlermeldungen, wenn der Programmierer das Semikolon am Ende der Klassendefinition (Zeile 27) vergißt...</em></p>
<h2 id="objektlebenszyklus">Objektlebenszyklus</h2>
<p>Der Lebenszyklus eines C++-Objektes besteht aus den Abschnitten</p>
<ol>
<li>Erzeugung</li>
<li>Benutzung</li>
<li>Zerstörung</li>
</ol>
<h3 id="erzeugen_eines_objektes">Erzeugen eines Objektes</h3>
<p>Das Erzeugen eines Objektes erfogt durch Aufruf des <em>Konstruktors</em> (kurz <em>ctor</em>) des Objektes. Dies kann sowohl statisch durch Variablendeklaration als auch dynamisch mittels des <tt class="keyword">new</tt> Operators geschehen:</p>
<pre class="cplus">
StockItem bay;
<span class="slashslashcomment">// default constructor, statisch</span>

StockItem dte( <span class="quotedstring">"Deutsche Telekom AG"</span>, 50.34);
<span class="slashslashcomment">// spezieller ctor, statisch</span>

StockItem *bas = <span class="keyword">new</span> StockItem( <span class="quotedstring">"BASF"</span>, 120.34);
<span class="slashslashcomment">// spezieller ctor, dynamisch </span>
<span class="slashslashcomment">// der für bas nötige Speicherplatz wird auf dem Heap alloziert</span>
</pre>
<h3 id="benutzen_eines_objektes">Benutzen eines Objektes</h3>
<p>Ein Objekt wird benutzt, indem eine seiner Methoden aufgerufen wird:</p>
<pre class="cplus">
dte.setValue( 52.80);
<span class="slashslashcomment">// ruft Methode StockItem::setValue() des Objektes dte auf</span>

a = bas-&gt;getValue();
<span class="slashslashcomment">// ruft Methode StockItem::getValue() des Objektes bas auf </span>
</pre>
<p>Außerdem kann das komplette Objekt als Parameter an eine Funktion übergeben oder von dieser per <tt class="keyword">return</tt> zurückgegeben werden. Erfolgt die Wertübergabe dabei <em>per Value</em>, so wird implizit der <em>Copy Konstruktor</em> des Objektes aufgerufen:</p>
<pre class="cplus">
StockItem cnv( StockItem x) {
    <span class="slashslashcomment">// ...</span>

    <span class="keyword">return</span> x2;
    <span class="slashslashcomment">// return per value: ruft den Copy Constructor von x2 auf</span>
}

StockItem bas( <span class="quotedstring">"BASF"</span>, 120.34);
cnv( bas);
<span class="slashslashcomment">// parameter per value: ruft den Copy Constructor von bas auf</span>

StockItem bas2 = bas;
<span class="slashslashcomment">// explizite Kopie: ruft den Copy Constructor von bas2 auf </span>
</pre>
<p>Ebenso kann ein Objekt komplett einem anderen bereits existierenden Objekt zugewiesen werden, wenn dieses den gleichen Typ oder den Typ einer Basisklasse hat. Dann wird der <em>Assignment Operator</em> des Objektes aufgerufen:</p>
<pre class="cplus">
StockItem x;
StockItem y( <span class="quotedstring">"ABC"</span>, 22);

x = y;
<span class="slashslashcomment">// ruft den Assignment Operator von x auf</span>
</pre>
<h3 id="zerst">Zerstören eines Objektes</h3>
<p>Wird ein Objekt nicht mehr benötigt, so sollte es zerstört werden, damit es keinen Speicherplatz mehr verbraucht. Bei der Zerstörung eines Objektes wird automatisch sein <em>Destruktor</em> (kurz <em>dtor</em>) aufgerufen. Im Falle eines dynamisch per <tt class="keyword">new</tt> erzeugten Objektes wird dies mit dem Operator <tt class="keyword">delete</tt> bewerkstelligt. Ein statisch erzeugtes Objekt wird automatisch zerstört, wenn bei der Programmausführung der Gültigkeitsbereich der statischen Deklaration verlassen wird:</p>
<pre class="cplus">
<span class="keyword">delete</span> bas;
<span class="slashslashcomment">// der Destructor des Objektes bas wird aufgerufen und anschließend</span>
<span class="slashslashcomment">// der durch bas belegte Speicherplatz freigegeben</span>
<span class="keyword">if</span> (x) {
    StockItem bmw;
    <span class="slashslashcomment">// ...</span>
} <span class="slashslashcomment">// der dtor des statisch angelegten Objektes bmw wird hier am Blockende</span>
<span class="slashslashcomment">// wegen des Verlassens des Gültigkeitsbereiches der Deklaration aufgerufen</span>
</pre>
<p><strong>Beachte:</strong>Der Destruktor eines Objektes wird in der Regel niemals direkt aufgerufen, sondern sein Aufruf erfolgt wie oben dargestellt implizit durch Verwendung von <tt class="Keyword">delete</tt> oder beim Verlassen des Gültigkeitsbereiches!</p>
<h2 id="objektimplementierung">Objektimplementierung</h2>
<p>Was uns nun noch zum ersten vollständigen C++-Programm fehlt, ist die Implementierung der einzelnen Methoden des Objektes StockItem.</p>
<p>Die Implementierung wird vorzugsweise in einer Datei mit Namen <b>StockItem.cpp</b> vorgenommen. Zu Beginn wird die Headerdatei <b>StockItem.h</b> inkludiert:</p>
<pre class="cplus">
<span class="comment">/*  1 */</span>  <span class="preprocessor">#include "StockItem.h"</span>
<span class="comment">/*  2 */</span>  <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="comment">/*  3 */</span>  <span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="comment">/*  4 */</span> 
<span class="comment">/*  5 */</span>  StockItem::StockItem( <span class="keyword">const</span> <span class="keyword">char</span>* name <span class="comment">/* = "" */</span>, <span class="keyword">double</span> val <span class="comment">/* = 0.0 */</span>)
<span class="comment">/*  6 */</span>  {
<span class="comment">/*  7 */</span>      m_name = <span class="keyword">new</span> <span class="keyword">char</span>[strlen(name)+1];
<span class="comment">/*  8 */</span>      strcpy( m_name, name);
<span class="comment">/*  9 */</span>      m_value = val;
<span class="comment">/* 10 */</span>  }
<span class="comment">/* 11 */</span>
<span class="comment">/* 12 */</span>  StockItem::StockItem( <span class="keyword">const</span> StockItem &amp;right)
<span class="comment">/* 13 */</span>
<span class="comment">/* 14 */</span>  {
<span class="comment">/* 15 */</span>
<span class="comment">/* 16 */</span>      m_name = <span class="keyword">new</span> <span class="keyword">char</span>[strlen( right.m_name)+1];
<span class="comment">/* 17 */</span>      strcpy( m_name, right.m_name);
<span class="comment">/* 18 */</span>      m_value = right.m_value;
<span class="comment">/* 19 */</span>  }
<span class="comment">/* 20 */</span>
<span class="comment">/* 21 */</span>  StockItem::~StockItem()
<span class="comment">/* 22 */</span>  {
<span class="comment">/* 23 */</span>      <span class="keyword">delete</span>[] m_name;
<span class="comment">/* 24 */</span>  }
<span class="comment">/* 25 */</span>
<span class="comment">/* 26 */</span>  <span class="keyword">const</span> StockItem&amp; StockItem::<span class="keyword">operator</span>=(<span class="keyword">const</span> StockItem &amp;right)
<span class="comment">/* 27 */</span>  {
<span class="comment">/* 28 */</span>      <span class="slashslashcomment">// handle self assignment</span>
<span class="comment">/* 29 */</span>      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;right) {
<span class="comment">/* 30 */</span>          <span class="keyword">delete</span>[] m_name;
<span class="comment">/* 31 */</span>          m_name = <span class="keyword">new</span> <span class="keyword">char</span>[strlen( right.m_name)+1];
<span class="comment">/* 32 */</span>          strcpy( m_name, right.m_name);
<span class="comment">/* 33 */</span>          m_value = right.m_value;
<span class="comment">/* 34 */</span>      }
<span class="comment">/* 35 */</span>
<span class="comment">/* 36 */</span>      <span class="keyword">return</span> *<span class="keyword">this</span>;
<span class="comment">/* 37 */</span>  }
<span class="comment">/* 38 */</span>
<span class="comment">/* 39 */</span>  <span class="keyword">const</span> <span class="keyword">char</span>* StockItem::getName() <span class="keyword">const</span>
<span class="comment">/* 40 */</span>  {
<span class="comment">/* 41 */</span>      <span class="keyword">return</span> m_name;
<span class="comment">/* 42 */</span>  }
<span class="comment">/* 43 */</span>
<span class="comment">/* 44 */</span>  <span class="keyword">void</span> StockItem::setValue( <span class="keyword">double</span> val)
<span class="comment">/* 45 */</span>  {
<span class="comment">/* 46 */</span>      m_value = val;
<span class="comment">/* 47 */</span>  }
<span class="comment">/* 48 */</span>
<span class="comment">/* 49 */</span>  <span class="keyword">void</span> StockItem::setValue( <span class="keyword">const</span> <span class="keyword">char</span>* val)
<span class="comment">/* 50 */</span>  {
<span class="comment">/* 51 */</span>      m_value = atof( val);
<span class="comment">/* 52 */</span>  }
<span class="comment">/* 53 */</span>
<span class="comment">/* 54 */</span>  <span class="keyword">double</span> StockItem::getValue() <span class="keyword">const</span>
<span class="comment">/* 55 */</span>  {
<span class="comment">/* 56 */</span>      <span class="keyword">return</span> m_value;
<span class="comment">/* 57 */</span>  } 
</pre>
<p>Die Implementierung der öffentlichen Methoden für das Setzen und Auslesen der Werte der Attribute in den Zeilen 39 bis 57 enthält nichts besonderes, der Code dürfte für sich sprechen.</p>
<p>Interessanter ist der Konstruktor (Zeilen 5 bis 10): Da wir den Namen des <tt>StockItem</tt> in einer C-Zeichenkette vom Typ <tt><span class="keyword">char</span>*</tt> speichern wollen, muß zuerst der hierfür notwendige Speicherplatz allokiert werden (Zeile 7). Da wir in C++ programmieren, verwenden wir nicht das aus der C-Welt vertraute <tt>malloc</tt>, sondern den C++-Operator <tt><span class="keyword">new</span>[]</tt>.</p>
<p>Ähnlich verhält sich die Sache beim Copy Konstruktor (Zeilen 12 bis 19): Hier ist das einzige Argument immer eine Referenz auf ein Objekt des gleichen Typs. Dessen Membervariablen müssen in die eigenen Variablen <em>kopiert</em> werden, damit eine 1:1 Kopie des Objektes entsteht. Wir erinnern uns: Der Copy Konstruktor wird bei Übergabe von Objekten per Value an oder aus Funktionen oder beim expliziten Kopieren verwendet.</p>
<p>Noch interessanter gestaltet sich die Sache beim Assignment Operator (Zeilen 26 bis 37): Hier existiert ja schon ein Objekt x, in das ein zweites Objekt y hineinkopiert wird! Also muß <em>zuerst</em> der von x belegte Speicherplatz freigegeben werden (Zeile 30), bevor die Variablen kopiert werden können. In der C++-Sprache bezeichnet man übrigens unser Objekt x als <tt class="keyword">this</tt>. Der Bezug auf das eigene Objekt <tt class="keyword">this</tt> ist so wichtig, daß <tt class="keyword">this</tt> sogar ein reserviertes Wort in C++ ist und immer innerhalb von Objektfunktionen zur Verfügung steht. Der Assignment Operator gibt einen Zeiger auf das Objekt selbst (also auf <tt class="keyword">this</tt>) zurück, schließlich wird er ja in Zuweisungen wie</p>
<pre class="cplus">
StockItem x;
StockItem y( <span class="quotedstring">"ABC"</span>, 22);

x = y;
</pre>
<p>verwendet.</p>
<p>Übrigens hindert niemand den Programmierer, statt x = y die Zuweisung x = x hinzuschreiben! Dann haben wir den Fall des <em>Self Assignments</em> vorliegen: Ein Objekt wird sich selbst zugewiesen. Dann darf der Assignment Operator auch nichts weiter tun. Die Abfrage, ob Self Assignment vorliegt, findet in Zeile 29 statt.</p>
<p>Der mittels <tt><span class="keyword">new</span>[]</tt> vom Betriebssystem während der Objektkonstruktion explizit angeforderte Speicherplatz muß beim Zerstören des Objektes auch wieder ausdrücklich freigegeben werden. Wir erinnern uns: Beim Zerstören des Objektes wird automatisch sein Destruktor ausgeführt. Deswegen wird im Destruktor (Zeilen 21 bis 24) der für m_name angeforderte Speicherbereich mittels <tt><span class="keyword">delete</span>[]</tt> freigegeben.</p>
<h2 id="vererbung">Vererbung</h2>
<h3 id="konzept">Konzept</h3>
<p>Vererbung erlaubt die Definition neuer Klassen auf der Basis von bestehenden Klassen. Dies ist ein grundlegendes Konzept objektorientierten Designs. <img align="left" alt="Vererbung" height="107" src="images/c++-part6.gif" width="173"> Weiter oben wurde der Begriff der <em>Klasse</em> als eine Art Bauplan für Objekte erklärt. Anhand des dort verwendeten Beispiels "Fahrrad" lassen sich weitere Parallelen zur realen Welt ziehen: Es fällt auf, daß es hier <em>verschiedene Arten</em> von Fahrrädern gibt: Rennräder, Montainbikes, Treckingräder und das gute alte Hollandrad. Warum sind alle diese verschiedenen Räder für uns als Fährräder erkennbar? Weil sie gewisse gemeinsame Eigenschaften haben: Alle haben zwei Räder, einen Lenker und lassen sich durch Tritt auf die Pedale fortbewegen. Zusätzlich zu diesen Gemeinsamkeiten bringen sie aber auch neue Eigenschaften ein: Montainbikes und Rennräder haben jeweils eine Gangschaltung, unterscheiden sich aber durch die Art der Bereifung.</p>
<p>In objektorientierter Sprache könnte man also sagen: Die Klassen Montainbikes, Rennräder und Hollandräder <em>erben</em> von der Klasse Fahrräder gemeinsame Eigenschaften und fügen zusätzliche hinzu. Allgemein gilt:</p>
<ul>
<li>Klassen können definiert werden in Abhängigkeit von anderen Klassen: "A ist eine Art von B". In diesem Fall ist B die <em>Basisklasse</em> von A.</li>
<li>Eine Klasse kann auch von mehreren Klassen erben: A ist eine Art von B und C (Mehrfachvererbung).</li>
<li>Jede Klasse erbt die (öffentlichen) Attribute und Methoden ihrer Basisklasse(n).</li>
<li>Jedoch kann jede Klasse eigene Variablen und Methoden hinzufügen.</li>
</ul>
<p>Es ist wichtig zu verstehen, daß Vererbung nur in eine Richtung läuft: Ein Rennrad ist zwar immer auch ein Fahrrad, aber nicht jedes Fahrrad ist automatisch ein Rennrad. Wenn in C++ ein Objekt a der Klasse A definiert wird und die Klasse A von B abgeleitet ist, dann kann a jederzeit per Cast in ein Objekt vom Typ B umgewandelt werden. Die Umkehrung gilt nicht: Ein Objekt b der Klasse B kann in diesem Fall nicht in den Typ A umgewandelt werden!</p>
<h3 id="vererbung_in_c__">Vererbung in C++</h3>
<p>Die von uns bereits definierte und benutzte Klasse <em>StockItem</em> erlaubt die Speicherung eines Namens und eines dazugehörenden Wertes und ist zur Darstellung von Aktienkursen gedacht. Wer sich mit dieser Materie schon beschäftigt hat, der weiß, daß zu einer Aktie noch viele Informationen mehr gespeichert werden können. So gibt es neben dem (Tages- oder Wochen-)Schlusskurs (<em>Close</em>) noch Eröffnungs- (<em>Open</em>), Höchst- (<em>High</em>) und Tiefstkurs (<em>Low</em>). Wir wollen daher nun StockItem um die Möglichkeit erweitern, zusätzlich auch den Eröffnungskurs abfragen und setzen zu können.</p>
<p>Diese Erweiterung soll jedoch nicht durch Verändern der existierenden Klasse StockItem erfolgen - diese Klasse wird bereits in vielen Softwareprojekten benutzt und eine Änderung ihrer Funktionalität könnte unter Umständen böse Auswirkungen haben. Auch wollen wir das Rad nicht völlig neu erfinden - vorhandener Code soll so weit wie möglich wiederverwendet werden. Dies alles erreichen wir dadurch, daß wir eine neue Klasse <em>StockItemOC</em> definieren, die von der vorhandenen Klasse StockItem <em>abgeleitet</em> ist:</p>
<pre class="cplus">
<span class="comment">/*  1 */</span>  <span class="preprocessor">#ifndef StockItemOC_h</span>
<span class="comment">/*  2 */</span>  <span class="preprocessor">#define StockItemOC_h 1</span>
<span class="comment">/*  3 */</span>
<span class="comment">/*  4 */</span>  <span class="keyword">class</span> StockItemOC : <span class="keyword">public</span> StockItem {
<span class="comment">/*  5 */</span>
<span class="comment">/*  6 */</span>  <span class="keyword">public</span>:
<span class="comment">/*  7 */</span>      <span class="slashslashcomment">// ctor</span>
<span class="comment">/*  8 */</span>      StockItemOC( <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="quotedstring">""</span>, <span class="keyword">double</span> open = 0.0, <span class="keyword">double</span> close = 0.0);
<span class="comment">/*  9 */</span>
<span class="comment">/* 10 */</span>      <span class="slashslashcomment">// copy ctor</span>
<span class="comment">/* 11 */</span>      StockItemOC( <span class="keyword">const</span> StockItemOC &amp;right);
<span class="comment">/* 12 */</span>      <span class="slashslashcomment">// dtor</span>
<span class="comment">/* 13 */</span>      <span class="keyword">virtual</span> ~StockItemOC();
<span class="comment">/* 14 */</span>      <span class="slashslashcomment">// assignment operator</span>
<span class="comment">/* 15 */</span>      <span class="keyword">const</span> StockItemOC&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StockItemOC &amp;right);
<span class="comment">/* 16 */</span>
<span class="comment">/* 17 */</span>      <span class="slashslashcomment">// public member functions</span>
<span class="comment">/* 18 */</span>      <span class="keyword">virtual</span> <span class="keyword">void</span> setValue( <span class="keyword">double</span> val);
<span class="comment">/* 19 */</span>      <span class="keyword">virtual</span> <span class="keyword">double</span> getValue() <span class="keyword">const</span>;
<span class="comment">/* 20 */</span>      <span class="keyword">virtual</span> <span class="keyword">void</span> setOpen( <span class="keyword">double</span> val);
<span class="comment">/* 21 */</span>      <span class="keyword">virtual</span> <span class="keyword">double</span> getOpen() <span class="keyword">const</span>;
<span class="comment">/* 22 */</span>      <span class="keyword">virtual</span> <span class="keyword">void</span> setClose( <span class="keyword">double</span> val);
<span class="comment">/* 23 */</span>      <span class="keyword">virtual</span> <span class="keyword">double</span> getClose() <span class="keyword">const</span>;
<span class="comment">/* 24 */</span>
<span class="comment">/* 25 */</span>  <span class="keyword">private</span>:
<span class="comment">/* 26 */</span>      <span class="slashslashcomment">// private member variables</span>
<span class="comment">/* 27 */</span>      <span class="keyword">double</span> m_open;
<span class="comment">/* 28 */</span>      <span class="keyword">double</span> m_close;
<span class="comment">/* 29 */</span>  };
<span class="comment">/* 30 */</span>
<span class="comment">/* 31 */</span>  <span class="preprocessor">#endif</span>
</pre>
<p>Die einzige Erweiterung gegenüber der uns bekannten Klassendefinition ist, daß zu Beginn in Zeile 4 die Basisklasse nach dem Doppelpunkt und dem Schlüsselwort <tt class="keyword">public</tt> angegeben wird.</p>
<p>Welche Auswirkung hat diese Vererbungsbeziehung nun auf das Verhalten unserer neuen Klasse StockItemOC? Schauen wir uns dazu das UML-Diagramm an: <img align="left" alt="class StockItemOC" height="291" src="images/c++-part7.gif" width="173"></p>
<ul>
<li>StockItemOC <em>erbt</em> die Methode getName() von StockItem. Diese Methode braucht also nicht noch einmal implementiert zu werden.</li>
<li>StockItemOC <em>überschreibt</em> die Methoden setValue() und getValue() von StockItem. Diese Methoden müssen anders implementiert sein, da StockItemOC ja zwei Kurswerte statt einem zur Auswahl hat.</li>
<li>StockItemOC hat die <em>zusätzlichen</em> Methoden getOpen(), setOpen(), getClose() und setClose(), um die zusätzliche gewünschte Funktionalität abbilden zu können.</li>
<li>StockItemOC <em>erbt</em> die Variablen m_name und m_value von StockItem. Da diese Variablen dort aber als <em>private</em> deklariert sind, haben die Methoden von StockItemOC keinen Zugriff auf diese Variable - außer natürlich getName(), denn diese ist ja auch von StockItem geerbt.</li>
<li>StockItemOC deklariert die <em>zusätzlichen</em> privaten Variablen m_open und m_close.</li>
</ul>
<h3 id="implementierung_der_abgeleiteten_klasse">Implementierung der abgeleiteten Klasse</h3>
<p>Zunächst wollen wir einen Blick auf die Implementierung der abgeleiteten Klasse in <b>StockItemOC.cpp</b> werfen:</p>
<pre class="cplus">
<span class="comment">/*  1 */</span>  <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="comment">/*  2 */</span>  <span class="preprocessor">#include "StockItem.h"</span>
<span class="comment">/*  3 */</span>  <span class="preprocessor">#include "StockItemOC.h"</span>
<span class="comment">/*  4 */</span>
<span class="comment">/*  5 */</span>  StockItemOC::StockItemOC( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">double</span> open, <span class="keyword">double</span> close)
<span class="comment">/*  6 */</span>   : StockItem(name), m_open(open), m_close(close)
<span class="comment">/*  7 */</span>  { }
<span class="comment">/*  8 */</span>
<span class="comment">/*  9 */</span>  StockItemOC::StockItemOC( <span class="keyword">const</span> StockItemOC &amp;right)
<span class="comment">/* 10 */</span>   : StockItem(right), m_open(right.m_open), m_close(right.m_close)
<span class="comment">/* 11 */</span>  { }
<span class="comment">/* 12 */</span>
<span class="comment">/* 13 */</span>  StockItemOC::~StockItemOC()
<span class="comment">/* 14 */</span>  { }
<span class="comment">/* 15 */</span>
<span class="comment">/* 16 */</span>  <span class="keyword">const</span> StockItemOC&amp; StockItemOC::<span class="keyword">operator</span>=(<span class="keyword">const</span> StockItemOC &amp;right)
<span class="comment">/* 17 */</span>  {
<span class="comment">/* 18 */</span>      <span class="slashslashcomment">// handle self assignment</span>
<span class="comment">/* 19 */</span>      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;right) {
<span class="comment">/* 20 */</span>          StockItem::<span class="keyword">operator</span>=(right);
<span class="comment">/* 21 */</span>          m_open = right.m_open;
<span class="comment">/* 22 */</span>          m_close = right.m_close;
<span class="comment">/* 23 */</span>      }
<span class="comment">/* 24 */</span>
<span class="comment">/* 25 */</span>      <span class="keyword">return</span> *<span class="keyword">this</span>;
<span class="comment">/* 26 */</span>  }
<span class="comment">/* 27 */</span>
<span class="comment">/* 28 */</span>  <span class="keyword">void</span> StockItemOC::setValue( <span class="keyword">double</span> val)
<span class="comment">/* 29 */</span>  {
<span class="comment">/* 30 */</span>      m_close = val;
<span class="comment">/* 31 */</span>  }
<span class="comment">/* 32 */</span>
<span class="comment">/* 33 */</span>  <span class="keyword">double</span> StockItemOC::getValue() <span class="keyword">const</span>
<span class="comment">/* 34 */</span>  {
<span class="comment">/* 35 */</span>      <span class="keyword">return</span> m_close;
<span class="comment">/* 36 */</span>  }
<span class="comment">/* 37 */</span>
<span class="comment">/* 38 */</span>  <span class="keyword">void</span> StockItemOC::setOpen( <span class="keyword">double</span> val)
<span class="comment">/* 39 */</span>  {
<span class="comment">/* 40 */</span>      m_open = val;
<span class="comment">/* 41 */</span>  }
<span class="comment">/* 42 */</span>
<span class="comment">/* 43 */</span>  <span class="keyword">double</span> StockItemOC::getOpen() <span class="keyword">const</span>
<span class="comment">/* 44 */</span>  {
<span class="comment">/* 45 */</span>      <span class="keyword">return</span> m_open;
<span class="comment">/* 46 */</span>  }
<span class="comment">/* 47 */</span>
<span class="comment">/* 48 */</span>  <span class="keyword">void</span> StockItemOC::setClose( <span class="keyword">double</span> val)
<span class="comment">/* 49 */</span>  {
<span class="comment">/* 50 */</span>      m_close = val;
<span class="comment">/* 51 */</span>  }
<span class="comment">/* 52 */</span>
<span class="comment">/* 53 */</span>  <span class="keyword">double</span> StockItemOC::getClose() <span class="keyword">const</span>
<span class="comment">/* 54 */</span>  {
<span class="comment">/* 55 */</span>      <span class="keyword">return</span> m_close;
<span class="comment">/* 56 */</span>  }
</pre>
<p>Interessant ist hier zunächst wieder der Konstruktor (Zeilen 5 bis 7): Im Gegensatz zum Konstruktor von StockItem weiter oben erfolgt die Initialisierung der Variablen (m_open und m_close) hier nicht im Funktionsrumpf, sondern in einer <em>Initialisierungsliste</em>. Dies schafft vor allem Performancevorteile bei der Konstruktion der Objekte. Ferner müssen wir bedenken, daß die in der Basisklasse als privat deklarierten Variablen (wie m_name) hier nicht direkt angesprochen werden können. Um diese trotzdem korrekt zu initialisieren, wird der Konstruktor der Basisklasse in der Initialisierungsliste aufgerufen (Zeile 6).</p>
<p>Gleiches gilt für den Copy Konstruktor (Zeilen 9 bis 11), der den Copy Konstruktor der Basisklasse in seiner Initialisierungsliste aufführt. Und auch der Assignment Operator muss den der Basisklasse explizit aufrufen (Zeile 20). Lediglich beim Destruktor (Zeilen 13 und 14) ist das Verhalten anders. Hier stellt die C++ Laufzeitumgebung sicher, daß alle Destruktoren voneinander abgeleiteter Klassen in der richtigen Reihenfolge aufgerufen werden. Da in StockItemOC kein dynamisch allozierter Speicher verwendet wird, braucht der Destruktor auch nichts weiter zu tun.</p>
<p>Die restlichen Methoden von StockItemOC dienen dem Setzen und Auslesen der privaten Variablen und bieten nichts Neues.</p>
<h3 id="verwendung_abgeleiteter_klassen">Verwendung abgeleiteter Klassen</h3>
<p>Die Verwendung von abgeleiteten Klassen soll nun anhand der Klasse StockItemOC in einem kleinen Testprogramm demonstriert werden.</p>
<p>Am Anfang der Programmdatei müssen die benötigten Headerfiles inkludiert werden:</p>
<pre class="cplus">
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="preprocessor">#include "StockItem.h"</span>
<span class="preprocessor">#include "StockItemOC.h"</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> std;

<span class="keyword">int</span> main( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)
{
</pre>
<p>Als erste Übung werden wir zwei StockItem Objekte und ein StockItemOC Objekt statisch anlegen und diese dann zur Ausgabe einiger Werte benutzen:</p>
<pre class="cplus">
    StockItem a( <span class="quotedstring">"BAY"</span>, 34.9);
    StockItem b( <span class="quotedstring">"BAS"</span>);
    StockItemOC c( <span class="quotedstring">"DTE"</span>, 57.0, 59.4);

    b.setValue( 24.2);

    cout &lt;&lt; a.getName() &lt;&lt; <span class="quotedstring">": "</span> &lt;&lt; a.getValue() &lt;&lt; endl;
    cout &lt;&lt; b.getName() &lt;&lt; <span class="quotedstring">": "</span> &lt;&lt; b.getValue() &lt;&lt; endl;
    cout &lt;&lt; c.getName() &lt;&lt; <span class="quotedstring">": "</span> &lt;&lt; c.getValue() &lt;&lt; <span class="quotedstring">" ("</span>
         &lt;&lt; c.getOpen() &lt;&lt; <span class="quotedstring">" -&gt; "</span> &lt;&lt; c.getClose() &lt;&lt; <span class="quotedstring">")\n"</span>;
</pre>
<p>Dies bietet auf den ersten Blick nichts neues. Beim zweiten Hinsehen erkennen wir, daß in der letzten Zeile die Methode getName() des Objektes c, welches vom Typ StockItemOC ist, aufgerufen wird. Die Klasse StockItemOC hat aber gar keine Methode getName() definiert! Mit dem neu erworbenen Wissen über Vererbung ist jedoch klar, was passiert: Es wird einfach die von der Klasse StockItem <em>geerbte</em> Methode verwendet!</p>
<p>Interessant ist auch die Verwendung der Methode getValue(). Diese gibt es sowohl in StockItem als auch in StockItemOC. In diesem Beispiel ist jedoch relativ einfach zu verstehen, was passiert - sowohl für uns als auch für den C++-Compiler: In der letzten Zeile wird StockItemOC::getValue() aufgerufen, in den beiden Zeilen davor StockItem::getValue(). Das ist deshalb klar, weil der Typ der Objekte a, b und c bereits zur Übersetzungszeit bekannt ist und der Compiler entscheiden kann, welchen Methodenaufruf er verwenden muß. Dies wird auch als <em>statische</em> oder <em>frühe Bindung</em> bezeichnet.</p>
<p>Was passiert jedoch, wenn der Compiler beim Übersetzen den genauen Typ des Objektes noch nicht kennt? Sehen wir uns die Fortsetzung des Programmes an:</p>
<pre class="cplus">
    StockItem *astocks[3];
    astocks[0] = &amp;a;
    astocks[1] = &amp;b;
    astocks[2] = &amp;c;      <span class="slashslashcomment">// cast from StockItemOC* to StockItem*</span>
    
    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; 3; ++i) {
        cout &lt;&lt; astocks[i]-&gt;getName() &lt;&lt; <span class="quotedstring">": "</span> &lt;&lt; astocks[i]-&gt;getValue() &lt;&lt; endl;
    }
</pre>
<p>Beim Aufruf astocks[i]-&gt;getValue() muß je nachdem, ob der in astocks stehende Pointer auf ein Objekt vom Typ StockItem (bei Index 0 und 1) oder vom Typ StockItemOC (Index 2) zeigt, eine andere Methode aufgerufen werden. Dies kann erst zur Laufzeit entschieden werden, man spricht dann von <em>dynamischer</em> oder <em>später Bindung</em>. Wie kann nun aber das Laufzeitsystem entscheiden, welchen Typ das Objekt hat? Der Schlüssel hierzu ist die sogenannte vtable, in der die spezifischen Funktionssignaturen für jedes Objekt abgelegt sind. Eine Funktionssignatur wird jedoch nur dann richtig in die vtable eingetragen, wenn die Funktionen in der Klassendefinitionen als <tt class="keyword">virtual</tt> deklariert sind. Dies haben wir zum Glück in unseren Definitionen schon getan, so daß das Programm wie erwartet arbeitet. Folgende Regel sollte man sich beim Umgang mit C++ jedoch verinnerlichen:</p>
<p class="definition">Deklariere alle Memberfunktionen - inklusive des Destruktors - als virtual, wenn Du die Absicht hast, Vererbungsmechanismen zu verwenden!</p>
<p>Zum Schluß noch eine fortgeschrittene Anwendung unserer Objekte. Statt in ein Array werden sie in einen STL-Vektor gepackt. Anschließend werden die Objekte nach ihrem Wert (getValue()) sortiert und ausgegeben. Das alles funktioniert auch dann, wenn der Vektor sowohl Objekte vom Typ StockItem* als auch StockItemOC* enthält, weil wieder dynamische Bindung zum Einsatz kommt:</p>
<pre class="cplus">
    <span class="slashslashcomment">// get the stock items odered by price</span>
    vector&lt;StockItem*&gt; stocks;

    stocks.push_back(&amp;a);
    stocks.push_back(&amp;b);
    stocks.push_back(&amp;c); <span class="slashslashcomment">// cast from StockItemOC* to StockItem*</span>

    sort(stocks.begin(), stocks.end(), CompareStockPrice());

    cout &lt;&lt; endl &lt;&lt; <span class="quotedstring">"stock items odered by price\n"</span>;
    reverse_copy( stocks.begin(), stocks.end(), ostream_iterator&lt;StockItem*&gt;(cout));
}
</pre>
<p>Für die richtige Sortierung und die Ausgabe sind noch zwei Hilfsfunktionen notwendig, die vor main() in die Programmdatei eingefügt werden können: CompareStockPrice ist ein sogenannter <em>functor</em>. Er wird als Parameter an den Sortieralgorithmus <em>sort</em> übergeben und dient zum Vergleich zweier Objekte vom Typ StockItem. Die zweite Funktion ist der Ausgabeoperator für ein StockItem Objekt. Dieser wird im Alorithmus <em>reverse_copy</em> über den <em>ostream_iterator</em> verwendet.</p>
<pre class="cplus">
<span class="slashslashcomment">// compare two stock prices</span>
<span class="keyword">class</span> CompareStockPrice {
<span class="keyword">public</span>:
    <span class="keyword">int</span> <span class="keyword">operator</span>()( <span class="keyword">const</span> StockItem* s1, <span class="keyword">const</span> StockItem* s2)
    { <span class="keyword">return</span> s1-&gt;getValue() &lt; s2-&gt;getValue(); }
};

<span class="slashslashcomment">// operator&lt;&lt; for class StockItem</span>
<span class="slashslashcomment">// write name and value to output stream ost</span>
ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; ost, <span class="keyword">const</span> StockItem* item) {
    ost &lt;&lt; item-&gt;getName() &lt;&lt; <span class="quotedstring">": "</span> &lt;&lt; item-&gt;getValue() &lt;&lt; endl;
    <span class="keyword">return</span> ost;
}
</pre>
<p>Wie man sieht, reicht es völlig aus, die Hilfsfunktionen für die Klasse StockItem zu implementieren. Es ist beim Aufruf der Funktion dann egal, ob der aktuelle Parameter auf ein Objekt vom Typ StockItem oder StockItemOC zeigt. Dies ist ein Resultat (und Vorteil) der von uns implementierten Vererbungshierarchie.</p>
<h3 class="linklist" id="download">Download</h3>
<ul>
<li><a href="download/cpptutor.zip">Sourcecode des Tutorials</a></li>
</ul>
<div></div>
</div>
<div id="Footer">
<div class="copyright">Copyright © 2020&nbsp;Martin Kompf. All rights reserved. <a href="/imprint.html">Impressum</a>&nbsp;<a href="/imprint.html">Datenschutzerklärung</a></div>
</div>
<div id="Menu">
<div xmlns="" class="menuLabel">Allgemeines</div>
<div xmlns="" class="menuItem"><a href="index.html">Einführung</a></div>
<div xmlns="" class="menuItem"><a href="../imprint.html">Impressum</a></div>
<div xmlns="" class="menuLabel">Artikel</div>
<div xmlns="" class="menuItem"><a href="artikel/index.html">Übersicht</a></div>
<div xmlns="" class="menuLabel">Tutorials</div>
<div xmlns="" class="menuItem"><span class="menuSelected">C++ Tutorial</span></div>
<div xmlns="" class="menuItem"><a href="corbatut.html">CORBA Tutorial</a></div>
<div xmlns="" class="menuItem"><a href="emeocv.html">OpenCV Praxis</a></div>
<div xmlns="" class="menuLabel">Referenz</div>
<div xmlns="" class="menuItem"><a href="cliblist.html">ANSI C Library</a></div>
<div xmlns="" class="menuItem"><a href="posixlist.html">POSIX Library</a></div>
</div>
</body>
</html>
